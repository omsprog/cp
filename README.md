## How to approach a Problem in an Interview

1. Problem clarification:
    - Resitate the problem in your own words
    - Ask clarifying questions to gather all necessary constraints and edge cases
2. Algorithm Design:
    - Consider and discuss multiple possible solutions
    - Talk through these options, decide which one will work best and explain your choice
3. Approximate Complexity Analysis:
    - Provided an initial complexity analysis of your approach to demonstrate its effectiveness
4. Coding:
    - Use meaningful variables when possible
    - Making use of helper functions can help structure your code and avoid repetition
5. Restate Complexity:
    - Explain your reasoning, discuse trade-offs
6. Testing
    - Use a reasonable number of test cases to ensure the code is correct

## Effective Communication

The coding interview should be a conversation 

- Think out loud: Run through your thought processes
- Discuss alternatives approaches: let the interviewer know your options. Discuss pros and cons of each, and explain your final choice.
- Getting unstuck: If you find yourself stuck, explain where you are in your thought process. 
- Thinking time: It's useful to take a moment to thunk about a problem in a period of silence.

## Questions to ask during the recruiter call

- What are each of the steps in the rest of the process?
- How long does it take to get through the process on average?
- What to expect during the technical phone screen
- How long does it take to hear back about next steps

## Good questions to ask

- What does a typical day look like?
- What is your stack
- What portion of your time is spent working on new stuff vs existing stuff
- What are you working on right now

## Throwaway interviews

- Pick companies whose interview styles are as close as possible to your target companies: If you know that your target company asks algorithmic questions, stay away from companies whose primary technical evaluation consists of presenting projects or doing code reviews.

- Choose companies with comparable bars to your target companies

## Post-mortem logs

Finishing a question is where the the long-term learning starts, we can maximize the value of practicing if we take a few minutes to fill out a post-mortem log reflecting on how we did.

- What could I have done differently?
- What mistakes do I keep making, and how can I adjust my workflow to address them?
- Is there anything I should add to my cheat sheet?

## Concepts

Time complexity from worst to best  

`O(1)` Constant   
`O(log n)` Algorithm that cuts input in half at every step. Binary Search.     
`O(n)` Traverse elements of array  
`O(n log n)` Merge sort  
`O(n ^ 2)` Nested for  
`O(2 ^ n)` Time taken doubles with each eddition to N, fibonacci  
`O(n!)`  

Space complexity: How much auxiliary memory is needed to run the algorithm  

## Links

- [LeetCode 75](https://leetcode.com/studyplan/leetcode-75/)
- [CSES Problem Set](https://cses.fi/problemset/)

## Fundamentals

- Fibonacci sequence with memoization
- Fibonacci sequence iterative

## Resources

- Programming Challenges by Skiena and Revilla
- Competitive Programming 4 by Halim and Halim
- Algorithmic Thinking by Daniel Zingaro
- Competitive Programming in Python by Durr and Vie
- Algorithm Design by Kleinber and Trdo
- The Algorithm Design Manual by Skiena